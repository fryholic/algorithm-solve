#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stack>
#include <cstring>
#include <string>

using namespace std;

int main() 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;

    vector<int> A(N);
    stack<int> original_stack;

    for(int i = 0; i < N; i++)
    {
        cin >> A[i];
    }

    // 여기까지는 O(N)을 만족

    vector<int> NGE(N, -1);

    for(int i = N - 1; i >= 0; i--)
    {
        if(i == N - 1)
        {
            NGE[i] = -1;
            original_stack.push(A[i]);
        }
        else
        {
            while(!original_stack.empty())
            {
                if(original_stack.top() <= A[i])
                {
                    original_stack.pop();
                }
                else
                {
                    NGE[i] = original_stack.top();
                    break;
                }
            }
            if(original_stack.empty())
            {
                NGE[i] = -1;
            }
            original_stack.push(A[i]);
        }
    }

    for(int i = 0; i < N; i++)
    {
        cout << NGE[i] << " ";
    }

    return 0;
}

/*

A = [3, 5, 2, 7]

NGE(1) = 5
NGE(2) = 7
NGE(3) = 7
NGE(4) = -1

1 <= N <= 1000000

1 <= A[i] <= 1000000

만약 A[1] ~ A[1000000] 에 대해서
NGE(1) ~ NGE(1000000)을 구하는 과정에서
오른쪽 끝 원소는 반드시 NGE(N) = -1이다.

위의 예시에서 내가 어떻게 자연스럽게 구하게 되었는지 자세하게 그 과정을 적어보면

1. 처음에 A 배열을 보고, 각 원소에 대해 NGE를 구해야겠다고 생각했다.
2. A[1] = 3을 보고, 오른쪽에 있는 원소들 중에서 3보다 큰 원소를 찾았다. 5가 가장 먼저 발견되어 NGE(1) = 5가 되었다.
3. A[2] = 5를 보고, 오른쪽에 있는 원소들 중에서 5보다 큰 원소를 찾았다. 7이 발견되어 NGE(2) = 7이 되었다.
4. A[3] = 2를 보고, 오른쪽에 있는 원소들 중에서 2보다 큰 원소를 찾았다. 7이 발견되어 NGE(3) = 7이 되었다.
5. A[4] = 7을 보고, 오른쪽에 있는 원소들 중에서 7보다 큰 원소를 찾았다. 없으므로 NGE(4) = -1이 되었다.
6. 이 과정을 반복하여 모든 원소에 대한 NGE를 구할 수 있었다.

더 자세히,

1. A[1] = 3을 보고, 오른쪽의 {5, 2, 7}을 본다.
1-1. A[1] = 3보다 크고, 가장 먼저 발견되는 원소는 5이다. 그렇게 NGE(1) = 5가 되었다.
2. A[2] = 5를 보고, 오른쪽의 {2, 7}을 본다.
2-1. A[2] = 5보다 크고, 가장 먼저 발견되는 원소는 7이다. 그렇게 NGE(2) = 7이 되었다.
3. A[3] = 2를 보고, 오른쪽의 {7}을 본다.
3-1. A[3] = 2보다 크고, 가장 먼저 발견되는 원소는 7이다. 그렇게 NGE(3) = 7이 되었다.
4. A[4] = 7을 보고, 오른쪽의 {}을 본다.
4-1. A[4] = 7보다 크고, 가장 먼저 발견되는 원소는 없다. 그렇게 NGE(4) = -1이 되었다.

그러면, 일반적인 상황을 가정했을 때, N개의 원소가 존재하고, 첫 번째 원소부터 이러한 과정을 반복한다고 가정하자.
이 때 각 원소에 대해서
N-1개의 원소에 대해서 순차적으로 검색,
N-2개의 원소에 대해서 순차적으로 검색,
...
1개의 원소에 대해서 순차적으로 검색
마지막 원소는 -1.

의 과정을 반복하면 O(N^2) 이 된다.

이 문제의 분류는 '스택' 이었는데, 이걸 통해서 O(N^2)를 극복할 수 있는가?

우선 첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에 수열 A의 원소들이 주어진다.

이 때 수열 A를 배열로도 갖되 스택으로도 초기화할 수 있는가?

1. N을 입력받는다.
2. A 배열에 원소를 입력받는다.
3. 그 원소를 토대로 스택을 초기화한다.
4. N개의 원소를 모두 순회한다.
4-1. N번째 원소가 조건문에서 가리켜질 때에 스택의 top 원소가 N번째 원소와 같은지 확인한다.
4-2. 만약 같다면, 이제 비교를 시작한다.
4-3. 스택의 top 원소가 N번째 원소보다 작다면, pop 한다.
4-4. 스택의 top 원소가 N번째 원소보다 크다면, N번째 원소의 NGE는 스택의 top 원소가 된다.

이런 과정에서는 pop 되는 원소들이 존재하므로 매번 스택을 새로 생성해야 한다.

스택의 top 원소가 N번째 원소보다 작다면, pop 한 후에 N번째 원소와 비교를 계속 진행하게 되는데

그 경우도 마찬가지로 pop 된다면 결국 다시 push 하지 않으면 재사용할 수 없기 때문이다.

임의의 배열 인덱스 N1 ~ N2의 부분 배열에 대한 스택을 생성할 수 있는가?

스택의 초기화를 어떻게 구현할 수 있는가?

계속하여 복사 생성자를 호출하는 것 보다는 어쩌면,

N번째 원소를 비교하면서 pop 되는 원소들을 별도의 큐에 저장해두었다가

비교가 끝나면 다시 스택에 push 하는 편이 좋을 것 같다.

이 경우에는 N * N-1 * N-2 * ... * 1 = N! 의 시간 복잡도와 어느 정도 차이가 있을지 모른다.

이 방법으로 시도해보자.


시도 해 본 결과

이것도 결국? O(N^2) 이 되는 것과 같다.

O(N)에 해결해야 한다. 어떻게?

순회가 한 번 이루어지며, 그와 관련하여 스택 또한 순회의 1 step에서 push/pop이 이루어져야 한다는 것임...

이런 방식을 어떻게 구현할 수 있는가?

순차적인 순회에서의 방식에서

1. 현재 인덱스의 원소를 확인
2. -> 여기서부터가 문제인 것 아닌지? 뒤의 모든 원소들을 스택에 넣느냐 마느냐는 여기서부터 해결되지 못한다.

그러면 역순회?

1. 마지막 인덱스(N-1)의 원소를 확인
2. -> 무조건 NGE는 -1
3. 그 다음은? 이전 인덱스(N-2)와 비교해서 N-1이 더 크면 NGE(N-2) = A[N-1]임
4. N-3은? N-2, N-1과 비교해서 구해야 하는데?
5. N-4는? N-3, N-2, N-1과 비교해서 구해야 함...

순차적인 순회에서는 그 인덱스 다음에 오는 모든 원소들을 스택에 넣고 그 top과 비교하는
생각을 하고 있었다면

역순회를 한다고 하면
맨 마지막을 -1로 둘 수 있으니까, 그 다음에 스택에 넣고 자연스럽게 스택의 원소가
하나 둘 씩 늘어나는 것에 대해 대응할 수 있게 된다.

그러면 이런 방식에 대해서는?

A[] 배열이 존재하고?

A[N-1]을 보고, NGE(N-1) = -1로 둔다.
그리고 A[N-1]을 스택에 삽입한다.

A[N-2]를 보고, 스택의 top과 비교한다.
만약 스택이 top이 A[N-2]보다 작다면?
스택에서 pop?

그러면
A[N-3]을 볼 때, 스택에 아무것도 존재하지 않는다. 이 경우에는?
NGE(N-3) = -1?

그냥 pop한다는 것은 맞지 않는 것 같다.

그러니까, pop을 한다면 그 경우에는 추가적으로 해줘야 할 것이 있을 것 같다.

그게 뭘까?

A[N-2]를 보고 스택의 top과 비교, pop을 하게 된다면
A[N-2]를 스택에 push해야 한다.
어쨌든 NGE는 해당하는 인덱스의 원소의 오른쪽에 있으면서? 그 인덱스의 원소보다 커야 하고?
그러면서도 가장 왼쪽에 있어야 하므로...

그러므로 최종 로직은
1. A[N-1]에 대해서 NGE(N-1) = -1로 둔다. A[N-1]을 스택에 push한다.
2. A[N-2]를 보고 스택의 top과 비교. top이 A[N-2]보다 작다면 pop, 크다면 NGE(N-2) = top.
그리고 A[N-2]를 스택에 push한다.
이 과정을 반복한다.

*/