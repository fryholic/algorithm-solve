# [Silver II] 마인크래프트 - 18111 

[문제 링크](https://www.acmicpc.net/problem/18111) 

### 성능 요약

메모리: 5224 KB, 시간: 400 ms

### 분류

브루트포스 알고리즘, 구현

### 제출 일자

2025년 4월 29일 16:24:12

### 문제 설명

<p>팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.</p>

<p>목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.</p>

<p>lvalue는 세로 <em>N</em>, 가로 <em>M</em> 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.</p>

<ol>
	<li>좌표 (<em>i</em>, <em>j</em>)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.</li>
	<li>인벤토리에서 블록 하나를 꺼내어 좌표 (<em>i</em>, <em>j</em>)의 가장 위에 있는 블록 위에 놓는다.</li>
</ol>

<p>1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.</p>

<p>단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 <em>B</em>개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.</p>

### 입력 

 <p>첫째 줄에 <i>N, M</i>, <em>B</em>가 주어진다. (1 ≤ <em>M</em>, <em>N</em> ≤ 500, 0 ≤ <em>B</em> ≤ 6.4 × 10<sup>7</sup>)</p>

<p>둘째 줄부터 <i>N</i>개의 줄에 각각 <i>M</i>개의 정수로 땅의 높이가 주어진다. (<em>i </em>+ 2)번째 줄의 (<em>j </em>+ 1)번째 수는 좌표 (<em>i</em>,<em> j</em>)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.</p>

### 출력 

 <p>첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.</p>


### 생각 과정

``` N * M 개의 블록이 주어지는데
각 블록의 높이는 0 ~ 256 이다.
각 블록의 높이를 0 ~ 256으로 맞추는데 드는 시간은
1. 높이를 높이는 경우 : 2초
2. 높이를 낮추는 경우 : 1초

그러면
예제에서는 unique한 경우를 보여줬지만
실제로는 높이를 맞추는 경우의 수가 많을 수 있다.
예를 들어서
1 2 3
2 3 4
3 4 5
이런 경우에는 높이의 분포가
1 2 3 4 5
로 이루어져서
5로 맞춘다고 할 때
높이가 1 : 4개
높이가 2 : 3개 * 2
높이가 3 : 2개 * 3
높이가 4 : 1개 * 2
로 '쌓기만' 한다
이 때 필요한 블록의 개수는
1 * 4 + 2 * 3 + 3 * 2 + 4 * 1 = 20
그리고 이게 B보다 작아야 한다
이 경우가 블록을 가장 많이 쌓는 경우가 된다

그렇다면
우선 주어진 블록 중 가장 높은 블록의 높이를	구하고
가장 낮은 블록의 높이를 구한다
그리고 모든 블록들이 가장 높은 블록의 높이로 쌓으려면
얼마나 필요한지 계산한다
그 다음에 B를 빼고 양수가 되면
그 높이로 쌓을 수 없는 것이다

문제에서는
답이 여러 개 있다면 그 중에서 가장 높은 블록을 쌓는 경우를 출력하라고 했다

이 방법과 같이
방금은 최대 높이를 기준으로 계산했지만
최대 높이에서 1을 뺀 기준으로 다시 계산해서
B를 빼고 0 또는 음수가 되는지 확인하도록 하면
어떤 높이로 쌓을 수 있는지 알 수 있다
그렇게 구한 높이에 대해서
모든 위치의 블록들에 대해
(구한 높이) - (각 블록의 높이) = d 를 계산하였을 때에
1. 음수인 경우 : 블록을 제거하는 것이므로 2초
2. 양수인 경우 : 블록을 쌓는 것이므로 1초
를 각각 블록에 d * 2 또는 d를 판단하고
이 모든 d * 2와 d를 더한 값을 구하면
땅을 고르는 데 걸리는 시간을 구할 수 있다

그런데
예제 입력 1을 보면
땅의 높이가 가장 높은 것이 아닌
다른 블록들은 0의 높이를 갖고 단 하나의 블록만 1의 높이를 갖는 경우인데
이 경우에는 1의 높이를 갖는 블록을 제거하기만 한다
왜냐하면 이 문제는 '최소시간'을 구하는 것이기 때문이다
그렇다면
방금 생각한 방법에 대해서
모든 높이에 대한 경우의 수를 구한 다음에
그 각각의 높이에 대한 소요 시간을 구하고
그 중에서 가장 적은 시간과 그에 따른 높이를 출력하면 된다

주어지는 입력은
N row * M column 이지만
굳이 2차원 배열을 만들지 않고
1차원 배열에서 높이의 min, max를 구하고
min부터 max까지 1씩 증가시키면서 B와의 차이를 확인하고
그 모든 경우의 수에 대해서
정수의 쌍을 저장하면 된다
그 쌍은 (소요시간, 높이)로 저장하고
출력할 때에는
소요 시간이 가장 적은 것을 찾는데
소요 시간이 같다면
높이가 가장 높은 것을 찾으면 된다
그것을 어떤 자료구조로 해야 할까
?
vector<pair<int, int>>로 하면
first는 소요시간, second는 높이로 저장할 수 있다
이 때 같은 소요 시간에 대해
second에 대한 비교를 수행할 수가 있는가?

추후에 sort를 사용할 때
bool compare(pair<int, int> a, pair<int, int> b) {
  if (a.first == b.first) {
	return a.second > b.second;
  }
  return a.first < b.first;
}

를 cmp로 사용하면

소요시간이 작은 순으로 우선 정렬되고 높이는 큰 순으로 정렬되므로
vector의 첫 번째 원소는 소요시간이 가장 적고 높이가 가장 높은 것이 온다...


실제로 코드를 작성해보니
4 2 5
64 64
65 65
64 64
64 64

이런 경우에 4 64가 출력되어야 하는데
실제로는 6 65가 출력된다
이 문제는 5개의 블록으로 64 높이의 블록 6개를 65로 만들 수는 없고
그 반대는 가능한 것인데, 현재의 로직에서는
for문 내의 block이 음수가 되는 경우가 있기 때문이다

현재 block_dist는 실제로 높이를 맞추는 데 필요한 블록의 개수이다
이 개수를 모두 합한 다음에 block과 비교해야하나?

일단 block < 0인 경우에는 vector에 넣지 않도록 했는데
그 코드에 대해서도 반례가 발생했고 실행 실패가 있었다

2 2 14
0 256
0 0

이 경우에는

512 0 이 출력되어야 하는데
576 64가 출력되었다

이 경우에는 분명 최소 높이가 0임에도 불구하고
최소 높이가 0이 되는 과정이 빠진 게 아닐까?

반복문의 조건에 등호를 넣어서 다시 실행해봤더니
정답 개수가 늘어났다

하지만 아직도 반례가 존재한다...

2 2 9
0 0
256 0

이 경우에는 512 0이 출력되어야 하는데
576 64가 출력되었다

다른 반례들도 전부 256 0 0 0 등의 경우인데
내 코드는 256을 등분하고 있다

런타임 에러가 발생하는 코드들은
256을 등분할 수 없는 경우이다

이것을 해결하려면
1. 블록을 쌓는 경우와
2. 블록을 제거하는 경우를 나누어야 한다
3. 블록을 쌓는 경우에는 1초가 걸리고
4. 블록을 제거하는 경우에는 2초가 걸린다
5. 블록을 쌓는 경우에는 B를 빼고
6. 블록을 제거하는 경우에는 B를 더해야 한다
7. 블록을 쌓는 경우에는 B가 0보다 작아지면 안 된다

```
